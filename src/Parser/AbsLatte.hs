module Parser.AbsLatte where

-- Haskell module generated by the BNF converter


newtype TIf = TIf ((Int,Int),String) deriving (Eq,Ord,Show)
newtype TWhile = TWhile ((Int,Int),String) deriving (Eq,Ord,Show)
newtype TFor = TFor ((Int,Int),String) deriving (Eq,Ord,Show)
newtype PIdent = PIdent ((Int,Int),String) deriving (Eq,Ord,Show)
newtype SemiC = SemiC ((Int,Int),String) deriving (Eq,Ord,Show)
data Program =
   Program [TopDef]
  deriving (Eq,Ord,Show)

data TopDef =
   GlFunDef { funDef :: FunDef }
 | ClsDef { clsName :: PIdent, items :: [ClsDefItem] }
 | ClsExtDef { clsName :: PIdent, super :: PIdent, items :: [ClsDefItem] }
  deriving (Eq,Ord,Show)

data FunDef = FunDef
 { returnType :: Type
 , funName :: PIdent
 , funArgs ::[Arg]
 , body :: Block
 } deriving (Eq,Ord,Show)

data ClsDefItem =
   AttrDef Decl SemiC
 | MethDef FunDef
  deriving (Eq,Ord,Show)

data Arg =
   Arg {argType :: Type, argName :: PIdent }
  deriving (Eq,Ord,Show)

data Stmt =
   Empty SemiC
 | BStmt Block
 | SDecl Decl SemiC
 | Ass LVal Expr SemiC
 | Incr LVal SemiC
 | Decr LVal SemiC
 | Ret Expr SemiC
 | VRet SemiC
 | If TIf Expr Stmt
 | IfElse TIf Expr Stmt Stmt
 | While TWhile Expr Stmt
 | For TFor Type PIdent Expr Stmt
 | SExp Expr SemiC
  deriving (Eq,Ord,Show)

data Block =
   Block [Stmt]
  deriving (Eq,Ord,Show)

data Decl =
   Decl Type [Item]
  deriving (Eq,Ord,Show)

data Item =
   NoInit PIdent
 | Init PIdent Expr
  deriving (Eq,Ord,Show)

data LVal =
   LVar PIdent
 | LArr Expr Expr
 | LAttr Expr PIdent
  deriving (Eq,Ord,Show)

data Type =
   Int
 | Str
 | Bool
 | Void
 | Arr Type
 | Cls PIdent
  deriving (Eq,Ord,Show)

data Expr =
   ELitInt Integer
 | EString String
 | ELitTrue
 | ELitFalse
 | ESelf
 | ELVal LVal
 | ECall PIdent [Expr]
 | EMethCall Expr PIdent [Expr]
 | ENewObj PIdent
 | ENewArr Type Expr
 | ENullCast PIdent
 | Neg Expr
 | Not Expr
 | EMul Expr MulOp Expr
 | EAdd Expr AddOp Expr
 | ERel Expr RelOp Expr
 | EAnd Expr Expr
 | EOr Expr Expr
  deriving (Eq,Ord,Show)

data AddOp =
   Plus
 | Minus
  deriving (Eq,Ord,Show)

data MulOp =
   Times
 | Div
 | Mod
  deriving (Eq,Ord,Show)

data RelOp =
   LTH
 | LE
 | GTH
 | GE
 | EQU
 | NE
  deriving (Eq,Ord,Show)

-- helpers

ident :: PIdent -> String
ident (PIdent (_, ident)) = ident

class Named a where
    name :: a -> PIdent

strName :: Named a => a -> String
strName n = ident $ name n

instance Named FunDef where
    name = funName

instance Named TopDef where
    name (GlFunDef funDef) = name funDef
    name cls = clsName cls

instance Named Item where
    name (NoInit name) = name
    name (Init name _) = name

class Positioned a where
    lineNo :: a -> Int

instance Positioned PIdent where
    lineNo (PIdent ((lineNo, _), _)) = lineNo

instance Positioned SemiC where
    lineNo (SemiC ((lineNo, _), _)) = lineNo

