module Parser.AbsLatte where

-- Haskell module generated by the BNF converter


newtype PIdent = PIdent ((Int,Int),String) deriving (Eq,Ord,Show)
newtype SemiC = SemiC ((Int,Int),String) deriving (Eq,Ord,Show)
data Program =
   Program [TopDef]
  deriving (Eq,Ord,Show)

data TopDef =
   GlFunDef FunDef
 | ClsDef PIdent [ClsDefItem]
 | ClsExtDef PIdent PIdent [ClsDefItem]
  deriving (Eq,Ord,Show)

data FunDef =
   FunDef Type PIdent [Arg] Block
  deriving (Eq,Ord,Show)

data ClsDefItem =
   AttrDef Decl SemiC
 | MethDef FunDef
  deriving (Eq,Ord,Show)

data Arg =
   Arg Type PIdent
  deriving (Eq,Ord,Show)

data Stmt =
   Empty SemiC
 | BStmt Block
 | SDecl Decl SemiC
 | Ass LVal Expr SemiC
 | Incr LVal SemiC
 | Decr LVal SemiC
 | Ret Expr SemiC
 | VRet SemiC
 | Cond Expr Stmt
 | CondElse Expr Stmt Stmt
 | While Expr Stmt
 | SForEach Type PIdent Expr Stmt
 | SExp Expr SemiC
  deriving (Eq,Ord,Show)

data Block =
   Block [Stmt]
  deriving (Eq,Ord,Show)

data Decl =
   Decl Type [Item]
  deriving (Eq,Ord,Show)

data Item =
   NoInit PIdent
 | Init PIdent Expr
  deriving (Eq,Ord,Show)

data LVal =
   LVar PIdent
 | LArr Expr Expr
 | LAttr Expr PIdent
  deriving (Eq,Ord,Show)

data Type =
   Int
 | Str
 | Bool
 | Void
 | Arr Type
 | Cls PIdent
  deriving (Eq,Ord,Show)

data Expr =
   ELitInt Integer
 | EString String
 | ELitTrue
 | ELitFalse
 | ESelf
 | ELVal LVal
 | ECall PIdent [Expr]
 | EMethCall Expr PIdent [Expr]
 | ENewObj PIdent
 | ENewArr Type Expr
 | ENullCast PIdent
 | Neg Expr
 | Not Expr
 | EMul Expr MulOp Expr
 | EAdd Expr AddOp Expr
 | ERel Expr RelOp Expr
 | EAnd Expr Expr
 | EOr Expr Expr
  deriving (Eq,Ord,Show)

data AddOp =
   Plus
 | Minus
  deriving (Eq,Ord,Show)

data MulOp =
   Times
 | Div
 | Mod
  deriving (Eq,Ord,Show)

data RelOp =
   LTH
 | LE
 | GTH
 | GE
 | EQU
 | NE
  deriving (Eq,Ord,Show)

