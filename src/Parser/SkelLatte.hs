module Parser.SkelLatte where

-- Haskell module generated by the BNF converter

import Parser.AbsLatte
import Parser.ErrM
type Result = Err String

failure :: Show a => a -> Result
failure x = Bad $ "Undefined case: " ++ show x

transTIf :: TIf -> Result
transTIf x = case x of
  TIf str  -> failure x


transTWhile :: TWhile -> Result
transTWhile x = case x of
  TWhile str  -> failure x


transTFor :: TFor -> Result
transTFor x = case x of
  TFor str  -> failure x


transPIdent :: PIdent -> Result
transPIdent x = case x of
  PIdent str  -> failure x


transSemiC :: SemiC -> Result
transSemiC x = case x of
  SemiC str  -> failure x


transProgram :: Program -> Result
transProgram x = case x of
  Program topdefs  -> failure x


transTopDef :: TopDef -> Result
transTopDef x = case x of
  GlFunDef fundef  -> failure x
  ClsDef pident clsdefitems  -> failure x
  ClsExtDef pident1 pident2 clsdefitems3  -> failure x


transFunDef :: FunDef -> Result
transFunDef x = case x of
  FunDef type' pident args block  -> failure x


transClsDefItem :: ClsDefItem -> Result
transClsDefItem x = case x of
  AttrDef decl semic  -> failure x
  MethDef fundef  -> failure x


transArg :: Arg -> Result
transArg x = case x of
  Arg type' pident  -> failure x


transStmt :: Stmt -> Result
transStmt x = case x of
  Empty semic  -> failure x
  BStmt block  -> failure x
  SDecl decl semic  -> failure x
  Ass lval expr semic  -> failure x
  Incr lval semic  -> failure x
  Decr lval semic  -> failure x
  Ret expr semic  -> failure x
  VRet semic  -> failure x
  If tif expr stmt  -> failure x
  IfElse tif expr stmt1 stmt2  -> failure x
  While twhile expr stmt  -> failure x
  For tfor type' pident expr stmt  -> failure x
  SExp expr semic  -> failure x


transBlock :: Block -> Result
transBlock x = case x of
  Block stmts  -> failure x


transDecl :: Decl -> Result
transDecl x = case x of
  Decl type' items  -> failure x


transItem :: Item -> Result
transItem x = case x of
  NoInit pident  -> failure x
  Init pident expr  -> failure x


transLVal :: LVal -> Result
transLVal x = case x of
  LVar pident  -> failure x
  LArr expr1 expr2  -> failure x
  LAttr expr pident  -> failure x


transType :: Type -> Result
transType x = case x of
  Int  -> failure x
  Str  -> failure x
  Bool  -> failure x
  Void  -> failure x
  Arr type'  -> failure x
  Cls pident  -> failure x


transExpr :: Expr -> Result
transExpr x = case x of
  ELitInt n  -> failure x
  EString str  -> failure x
  ELitTrue  -> failure x
  ELitFalse  -> failure x
  ESelf  -> failure x
  ELVal lval  -> failure x
  ECall pident exprs  -> failure x
  EMethCall expr pident exprs  -> failure x
  ENewObj pident  -> failure x
  ENewArr type' expr  -> failure x
  ENullCast pident  -> failure x
  Neg expr  -> failure x
  Not expr  -> failure x
  EMul expr1 mulop2 expr3  -> failure x
  EAdd expr1 addop2 expr3  -> failure x
  ERel expr1 relop2 expr3  -> failure x
  EAnd expr1 expr2  -> failure x
  EOr expr1 expr2  -> failure x


transAddOp :: AddOp -> Result
transAddOp x = case x of
  Plus  -> failure x
  Minus  -> failure x


transMulOp :: MulOp -> Result
transMulOp x = case x of
  Times  -> failure x
  Div  -> failure x
  Mod  -> failure x


transRelOp :: RelOp -> Result
transRelOp x = case x of
  LTH  -> failure x
  LE  -> failure x
  GTH  -> failure x
  GE  -> failure x
  EQU  -> failure x
  NE  -> failure x



